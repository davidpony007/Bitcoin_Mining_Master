/**
 * Redis å®¢æˆ·ç«¯é…ç½®
 * ç”¨äºç¼“å­˜ç”¨æˆ·ç­‰çº§ã€ç­¾åˆ°çŠ¶æ€ã€å¹¿å‘Šè®¡æ•°ç­‰é«˜é¢‘æ•°æ®
 * 
 * æ ¸å¿ƒç‰¹æ€§ï¼š
 * - è‡ªåŠ¨é™çº§ï¼šRedis ä¸å¯ç”¨æ—¶ç³»ç»Ÿä»å¯è¿è¡Œ
 * - æ™ºèƒ½é‡è¯•ï¼šæœ€å¤š 5 æ¬¡ï¼ŒæŒ‡æ•°é€€é¿
 * - å•ä¾‹æ¨¡å¼ï¼šå…¨å±€å…±äº«è¿æ¥
 */

const Redis = require('ioredis');

/**
 * Redis å®¢æˆ·ç«¯å°è£…ç±»
 * å•ä¾‹æ¨¡å¼ + é™çº§ç­–ç•¥
 */
class RedisClient {
  constructor() {
    this.client = null;
    this.isConnected = false;
  }

  /**
   * åˆå§‹åŒ–è¿æ¥
   * é…ç½®é‡è¯•ç­–ç•¥å’Œäº‹ä»¶ç›‘å¬
   */
  async connect() {
    try {
      this.client = new Redis({
        host: process.env.REDIS_HOST || '127.0.0.1',
        port: process.env.REDIS_PORT || 6379,
        password: process.env.REDIS_PASSWORD || undefined,
        db: process.env.REDIS_DB || 0,
        lazyConnect: true,
        
        // é‡è¯•ç­–ç•¥ï¼šæœ€å¤š 5 æ¬¡ï¼ŒæŒ‡æ•°é€€é¿
        retryStrategy: (times) => {
          if (times > 5) {
            console.log('âš ï¸  Redis è¿æ¥å¤±è´¥,å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°,ç³»ç»Ÿå°†ä»¥é™çº§æ¨¡å¼è¿è¡Œ(æ— ç¼“å­˜)');
            return null;
          }
          const delay = Math.min(times * 1000, 5000);
          console.log(`[Redis] ç¬¬${times}æ¬¡é‡è¯•ï¼Œå»¶è¿Ÿ${delay}ms`);
          return delay;
        },
        maxRetriesPerRequest: null,
        enableOfflineQueue: false,
        connectTimeout: 10000,
        
        // é”™è¯¯é‡è¿ç­–ç•¥
        reconnectOnError: (err) => {
          const targetError = 'READONLY';
          if (err.message.includes(targetError)) {
            console.log('âš ï¸  Redis READONLY é”™è¯¯ï¼Œå°è¯•é‡è¿...');
            return true;
          }
          return false;
        }
      });

      // äº‹ä»¶ç›‘å¬
      this.client.on('connect', () => {
        console.log('ğŸ”Œ Redis æ­£åœ¨è¿æ¥...');
      });

      this.client.on('ready', () => {
        console.log('âœ… Redis è¿æ¥æˆåŠŸ');
        this.isConnected = true;
      });

      this.client.on('error', (err) => {
        console.error('âŒ Redis é”™è¯¯:', err.message);
        this.isConnected = false;
      });

      this.client.on('close', () => {
        console.log('âš ï¸  Redis è¿æ¥å…³é—­');
        this.isConnected = false;
      });

      this.client.on('reconnecting', (delay) => {
        console.log(`ğŸ”„ Redis æ­£åœ¨é‡è¿... (å»¶è¿Ÿ: ${delay}ms)`);
      });

      this.client.on('end', () => {
        console.log('ğŸ›‘ Redis è¿æ¥å·²ç»ˆæ­¢,ç³»ç»Ÿå°†ä»¥é™çº§æ¨¡å¼è¿è¡Œ(æ— ç¼“å­˜)');
        this.isConnected = false;
      });

      // å»ºç«‹è¿æ¥
      try {
        await this.client.ping();
        console.log('âœ… Redis PING æˆåŠŸ');
      } catch (connectError) {
        console.warn('âš ï¸  Redis æœåŠ¡ä¸å¯ç”¨:', connectError.message);
        console.warn('âš ï¸  ç³»ç»Ÿå°†ä»¥é™çº§æ¨¡å¼è¿è¡Œ(æ‰€æœ‰ç¼“å­˜æ“ä½œå°†è¢«è·³è¿‡)');
        this.isConnected = false;
      }
      
      return this.client;
    } catch (error) {
      console.error('âŒ Redis åˆå§‹åŒ–å¤±è´¥:', error.message);
      console.warn('âš ï¸  ç³»ç»Ÿå°†ä»¥é™çº§æ¨¡å¼è¿è¡Œ(æ— ç¼“å­˜)');
      this.isConnected = false;
      return null;
    }
  }

  /**
   * å…³é—­è¿æ¥
   */
  async disconnect() {
    if (this.client) {
      await this.client.quit();
      console.log('âœ… Redis è¿æ¥å·²å…³é—­');
    }
  }

  /**
   * æ£€æŸ¥ Redis æ˜¯å¦å°±ç»ª
   */
  isReady() {
    return this.isConnected && this.client && this.client.status === 'ready';
  }

  // ==================== ç”¨æˆ·ç­‰çº§ç¼“å­˜ ====================

  /**
   * ç¼“å­˜ç”¨æˆ·ç­‰çº§ä¿¡æ¯
   * Key: user:level:{user_id}, Type: Hash, TTL: 24h
   */
  async cacheUserLevel(userId, level, points, speedMultiplier, dailyBonusActive, dailyBonusExpire) {
    if (!this.isReady()) {
      console.warn('âš ï¸  Redis ä¸å¯ç”¨,è·³è¿‡ç¼“å­˜æ“ä½œ');
      return false;
    }
    
    try {
      const key = `user:level:${userId}`;
      const data = {
        level: level.toString(),
        points: points.toString(),
        speed_multiplier: speedMultiplier.toString(),
        daily_bonus_active: dailyBonusActive ? '1' : '0',
        daily_bonus_expire: dailyBonusExpire || ''
      };
      
      await this.client.hmset(key, data);
      await this.client.expire(key, 86400);
      return true;
    } catch (error) {
      console.error('ç¼“å­˜ç”¨æˆ·ç­‰çº§å¤±è´¥:', error.message);
      return false;
    }
  }

  /**
   * è·å–ç”¨æˆ·ç­‰çº§ç¼“å­˜
   */
  async getUserLevel(userId) {
    if (!this.isReady()) {
      return null;
    }
    
    try {
      const key = `user:level:${userId}`;
      const data = await this.client.hgetall(key);
      
      if (!data || Object.keys(data).length === 0) {
        return null;
      }
      
      return {
        level: parseInt(data.level) || 1,
        points: parseInt(data.points) || 0,
        speedMultiplier: parseFloat(data.speed_multiplier) || 1.0,
        dailyBonusActive: data.daily_bonus_active === '1',
        dailyBonusExpire: data.daily_bonus_expire || null
      };
    } catch (error) {
      console.error('è·å–ç”¨æˆ·ç­‰çº§ç¼“å­˜å¤±è´¥:', error.message);
      return null;
    }
  }

  /**
   * åˆ é™¤ç”¨æˆ·ç­‰çº§ç¼“å­˜
   */
   * - æ¯æ—¥åŠ æˆæ¿€æ´»/å¤±æ•ˆï¼šåˆ é™¤ç¼“å­˜ï¼Œæ›´æ–°çŠ¶æ€
   * 
   * ã€ç­–ç•¥ã€‘
   * é‡‡ç”¨ Cache Invalidationï¼ˆç¼“å­˜å¤±æ•ˆï¼‰æ¨¡å¼ï¼Œè€Œé Cache Updateï¼ˆç¼“å­˜æ›´æ–°ï¼‰ï¼š
   * - ä¼˜ç‚¹ï¼šé€»è¾‘ç®€å•ï¼Œä¸ä¼šå‡ºç°æ•°æ®ä¸ä¸€è‡´
   * - ç¼ºç‚¹ï¼šä¸‹æ¬¡æŸ¥è¯¢éœ€è¦é‡æ–°ç¼“å­˜ï¼ˆå¯æ¥å—ï¼Œå› ä¸ºæŸ¥è¯¢é¢‘ç‡é«˜ï¼‰
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Promise<boolean>} true=åˆ é™¤æˆåŠŸ, false=åˆ é™¤å¤±è´¥æˆ– Redis ä¸å¯ç”¨
   * 
   * @example
   * // ç”¨æˆ·å‡çº§ååˆ é™¤ç¼“å­˜
   * await LevelService.upgradeUser(userId);
   * await redisClient.deleteUserLevel(userId);
   */
  async deleteUserLevel(userId) {
    if (!this.isReady()) {
      return false;
    }
    
    try {
      const key = `user:level:${userId}`;
      await this.client.del(key); // DELï¼šåˆ é™¤é”®
      return true;
    } catch (error) {
      console.error('åˆ é™¤ç”¨æˆ·ç­‰çº§ç¼“å­˜å¤±è´¥:', error.message);
      return false;
    }
  }

  // ==================== ç­¾åˆ°çŠ¶æ€ç¼“å­˜ ====================
  // ä½¿ç”¨ Hash ç»“æ„å­˜å‚¨ç­¾åˆ°ç›¸å…³çš„å¤šä¸ªå­—æ®µ

  /**
   * ç¼“å­˜ç”¨æˆ·ç­¾åˆ°çŠ¶æ€
   * 
   * ã€æ•°æ®ç»“æ„ã€‘
   * Key: user:checkin:{user_id}
   * Type: Hash
   * Fields: last_date, consecutive_days, bonus_active, bonus_expire
   * TTL: 48å°æ—¶ï¼ˆ172800ç§’ï¼‰
   * 
   * ã€ä¸ºä»€ä¹ˆ48å°æ—¶TTLã€‘
   * - ç­¾åˆ°æ•°æ®ç›¸å¯¹ç¨³å®šï¼Œæ¯å¤©åªå˜åŒ–ä¸€æ¬¡
   * - 48å°æ—¶å¯ä»¥è¦†ç›–è·¨æ—¶åŒºçš„åœºæ™¯
   * - å³ä½¿ç¼“å­˜å¤±æ•ˆï¼Œä»æ•°æ®åº“æŸ¥è¯¢ä¹Ÿä¸å½±å“æ€§èƒ½
   * 
   * ã€ä½¿ç”¨åœºæ™¯ã€‘
   * - åˆ¤æ–­ç”¨æˆ·ä»Šå¤©æ˜¯å¦å·²ç­¾åˆ°
   * - æ˜¾ç¤ºè¿ç»­ç­¾åˆ°å¤©æ•°
   * - æ£€æŸ¥ç­¾åˆ°å¥–åŠ±æ˜¯å¦æ¿€æ´»
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @param {string} lastDate - æœ€åç­¾åˆ°æ—¥æœŸï¼ˆYYYY-MM-DD æ ¼å¼ï¼‰
   * @param {number} consecutiveDays - è¿ç»­ç­¾åˆ°å¤©æ•°
   * @param {boolean} bonusActive - ç­¾åˆ°å¥–åŠ±æ˜¯å¦æ¿€æ´»
   * @param {string|null} bonusExpire - å¥–åŠ±è¿‡æœŸæ—¶é—´ï¼ˆISO æ ¼å¼ï¼‰
   * @returns {Promise<boolean>} true=ç¼“å­˜æˆåŠŸ, false=å¤±è´¥
   * 
   * @example
   * await redisClient.cacheCheckInStatus(
   *   'U001',
   *   '2025-12-15',
   *   7,              // è¿ç»­7å¤©
   *   true,           // å¥–åŠ±æ¿€æ´»
   *   '2025-12-22T00:00:00Z'
   * );
   */
  async cacheCheckInStatus(userId, lastDate, consecutiveDays, bonusActive, bonusExpire) {
    if (!this.isReady()) {
      return false;
    }
    
    try {
      const key = `user:checkin:${userId}`;
      const data = {
        last_date: lastDate,                            // æœ€åç­¾åˆ°æ—¥æœŸå­—ç¬¦ä¸²
        consecutive_days: consecutiveDays.toString(),   // æ•°å­—è½¬å­—ç¬¦ä¸²
        bonus_active: bonusActive ? '1' : '0',          // å¸ƒå°”è½¬ '1'/'0'
        bonus_expire: bonusExpire || ''                 // null è½¬ç©ºå­—ç¬¦ä¸²
      };
      
      await this.client.hmset(key, data);
      await this.client.expire(key, 172800); // 48å°æ—¶ = 172800ç§’
      return true;
    } catch (error) {
      console.error('ç¼“å­˜ç­¾åˆ°çŠ¶æ€å¤±è´¥:', error.message);
      return false;
    }
  }

  /**
   * è·å–ç”¨æˆ·ç­¾åˆ°çŠ¶æ€ç¼“å­˜
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Promise<Object|null>} ç­¾åˆ°çŠ¶æ€å¯¹è±¡æˆ– null
   * 
   * @example
   * const checkin = await redisClient.getCheckInStatus('U001');
   * if (checkin && checkin.lastDate === today) {
   *   console.log('ä»Šå¤©å·²ç­¾åˆ°');
   * }
   */
  async getCheckInStatus(userId) {
    if (!this.isReady()) {
      return null;
    }
    
    try {
      const key = `user:checkin:${userId}`;
      const data = await this.client.hgetall(key);
      
      if (!data || Object.keys(data).length === 0) {
        return null;
      }
      
      return {
        lastDate: data.last_date,
        consecutiveDays: parseInt(data.consecutive_days) || 0,
        bonusActive: data.bonus_active === '1',
        bonusExpire: data.bonus_expire || null
      };
    } catch (error) {
      console.error('è·å–ç­¾åˆ°çŠ¶æ€ç¼“å­˜å¤±è´¥:', error.message);
      return null;
    }
  }

  // ==================== æ¯æ—¥å¹¿å‘Šè®¡æ•°ç¼“å­˜ ====================
  // ä½¿ç”¨ String ç±»å‹å­˜å‚¨è®¡æ•°ï¼Œé…åˆ INCR å‘½ä»¤å®ç°åŸå­é€’å¢

  /**
   * å¢åŠ ä»Šæ—¥å¹¿å‘Šè§‚çœ‹æ¬¡æ•°
   * 
   * ã€æ•°æ®ç»“æ„ã€‘
   * Key: user:ad:today:{user_id}
   * Type: String (å­˜å‚¨æ•°å­—)
   * TTL: å½“å¤©ç»“æŸæ—¶è‡ªåŠ¨è¿‡æœŸ
   * 
   * ã€åŸå­æ“ä½œã€‘
   * ä½¿ç”¨ INCR å‘½ä»¤ï¼Œä¿è¯åœ¨é«˜å¹¶å‘ä¸‹è®¡æ•°å‡†ç¡®ï¼š
   * - INCR æ˜¯åŸå­æ“ä½œï¼Œä¸ä¼šå‡ºç°ç«æ€æ¡ä»¶
   * - å¦‚æœé”®ä¸å­˜åœ¨ï¼ŒINCR ä¼šå…ˆè®¾ä¸º 0 å†åŠ  1
   * 
   * ã€è‡ªåŠ¨è¿‡æœŸç­–ç•¥ã€‘
   * è®¡ç®—å½“å¤©å‰©ä½™æ—¶é—´ä½œä¸º TTLï¼š
   * - ç¬¬ä¸€æ¬¡ INCR æ—¶è®¾ç½® EXPIRE
   * - æ¯å¤© 00:00 è‡ªåŠ¨åˆ é™¤ï¼Œæ¬¡æ—¥é‡æ–°è®¡æ•°
   * 
   * ã€ä½¿ç”¨åœºæ™¯ã€‘
   * - é™åˆ¶ç”¨æˆ·æ¯å¤©æœ€å¤šçœ‹ 10 æ¬¡å¹¿å‘Š
   * - ç»Ÿè®¡ç”¨æˆ·å¹¿å‘Šè§‚çœ‹ä¹ æƒ¯
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Promise<number>} ä»Šæ—¥è§‚çœ‹æ¬¡æ•°ï¼ˆåŒ…å«æœ¬æ¬¡ï¼‰
   * 
   * @example
   * const count = await redisClient.incrementTodayAdCount('U001');
   * if (count > 10) {
   *   throw new Error('ä»Šæ—¥å¹¿å‘Šè§‚çœ‹æ¬¡æ•°å·²è¾¾ä¸Šé™');
   * }
   */
  async incrementTodayAdCount(userId) {
    if (!this.isReady()) {
      return 0;
    }
    
    try {
      const key = `user:ad:today:${userId}`;
      
      // INCRï¼šåŸå­é€’å¢ï¼Œè¿”å›é€’å¢åçš„å€¼
      const count = await this.client.incr(key);
      
      // è®¡ç®—å½“å¤©å‰©ä½™æ—¶é—´ï¼ˆç§’ï¼‰
      const now = new Date();
      const endOfDay = new Date(
        now.getFullYear(), 
        now.getMonth(), 
        now.getDate() + 1,  // æ˜å¤©
        0, 0, 0             // 00:00:00
      );
      const ttl = Math.floor((endOfDay - now) / 1000); // æ¯«ç§’è½¬ç§’
      
      // åªåœ¨ç¬¬ä¸€æ¬¡é€’å¢æ—¶è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ˆcount === 1ï¼‰
      if (count === 1) {
        await this.client.expire(key, ttl);
      }
      
      return count; // è¿”å›ä»Šæ—¥æ€»æ¬¡æ•°
    } catch (error) {
      console.error('å¢åŠ å¹¿å‘Šè®¡æ•°å¤±è´¥:', error.message);
      return 0; // å‘ç”Ÿé”™è¯¯è¿”å› 0ï¼Œè°ƒç”¨æ–¹åº”æŸ¥æ•°æ®åº“
    }
  }

  /**
   * è·å–ä»Šæ—¥å¹¿å‘Šè§‚çœ‹æ¬¡æ•°
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Promise<number>} ä»Šæ—¥è§‚çœ‹æ¬¡æ•°ï¼ˆ0 è¡¨ç¤ºæœªè§‚çœ‹æˆ– Redis ä¸å¯ç”¨ï¼‰
   * 
   * @example
   * const count = await redisClient.getTodayAdCount('U001');
   * console.log(`ä»Šå¤©å·²çœ‹ ${count} æ¬¡å¹¿å‘Šï¼Œè¿˜å¯ä»¥çœ‹ ${10 - count} æ¬¡`);
   */
  async getTodayAdCount(userId) {
    if (!this.isReady()) {
      return 0;
    }
    
    try {
      const key = `user:ad:today:${userId}`;
      const count = await this.client.get(key); // GETï¼šè·å–å­—ç¬¦ä¸²å€¼
      return count ? parseInt(count) : 0;       // å­—ç¬¦ä¸²è½¬æ•°å­—ï¼Œnull è¿”å› 0
    } catch (error) {
      console.error('è·å–å¹¿å‘Šè®¡æ•°å¤±è´¥:', error.message);
      return 0;
    }
  }

  // ==================== æ¨èäººå¹¿å‘Šè®¡æ•°ç¼“å­˜ ====================
  // è®°å½•æ¨èå…³ç³»ä¸­è¢«æ¨èè€…çš„å¹¿å‘Šè§‚çœ‹æ¬¡æ•°

  /**
   * å¢åŠ æ¨èäººçš„è¢«æ¨èè€…å¹¿å‘Šè§‚çœ‹æ¬¡æ•°
   * 
   * ã€æ•°æ®ç»“æ„ã€‘
   * Key: user:referral:ad:{referrer_id}:{referral_id}
   * Type: String (æ•°å­—)
   * TTL: 30å¤©ï¼ˆ2592000ç§’ï¼‰
   * 
   * ã€ä¸šåŠ¡é€»è¾‘ã€‘
   * æ¨èç³»ç»Ÿè§„åˆ™ï¼š
   * - A æ¨èäº† B
   * - B æ¯çœ‹ 1 æ¬¡å¹¿å‘Šï¼ŒA è·å¾—ä¸€å®šå¥–åŠ±
   * - è®°å½• B ä¸º A è´¡çŒ®çš„å¹¿å‘Šæ¬¡æ•°
   * 
   * ã€ä¸ºä»€ä¹ˆ30å¤©TTLã€‘
   * - æ¨èå¥–åŠ±é€šå¸¸æœ‰æ—¶æ•ˆæ€§ï¼ˆå¦‚30å¤©å†…æœ‰æ•ˆï¼‰
   * - è¿‡æœŸæ•°æ®è‡ªåŠ¨æ¸…ç†ï¼ŒèŠ‚çœå†…å­˜
   * - æ°¸ä¹…æ•°æ®å­˜å‚¨åœ¨æ•°æ®åº“ï¼ŒRedis åªåšè®¡æ•°ç¼“å­˜
   * 
   * @param {string} referrerId - æ¨èäººIDï¼ˆAï¼‰
   * @param {string} referralId - è¢«æ¨èäººIDï¼ˆBï¼‰
   * @returns {Promise<number>} B ä¸º A è´¡çŒ®çš„æ€»å¹¿å‘Šæ¬¡æ•°
   * 
   * @example
   * // B çœ‹äº†ä¸€æ¬¡å¹¿å‘Š
   * const count = await redisClient.incrementReferralAdCount('A_ID', 'B_ID');
   * // ç»™ A å‘æ”¾å¥–åŠ±
   * await rewardService.grantReferralBonus('A_ID', adRewardAmount);
   */
  async incrementReferralAdCount(referrerId, referralId) {
    if (!this.isReady()) {
      return 0;
    }
    
    try {
      const key = `user:referral:ad:${referrerId}:${referralId}`;
      const count = await this.client.incr(key);          // åŸå­é€’å¢
      await this.client.expire(key, 2592000);             // 30å¤© = 2592000ç§’
      return count;
    } catch (error) {
      console.error('å¢åŠ æ¨èå¹¿å‘Šè®¡æ•°å¤±è´¥:', error.message);
      return 0;
    }
  }

  /**
   * è·å–æ¨èå…³ç³»çš„å¹¿å‘Šè§‚çœ‹æ¬¡æ•°
   * 
   * @param {string} referrerId - æ¨èäººID
   * @param {string} referralId - è¢«æ¨èäººID
   * @returns {Promise<number>} å¹¿å‘Šè§‚çœ‹æ¬¡æ•°
   * 
   * @example
   * const count = await redisClient.getReferralAdCount('A_ID', 'B_ID');
   * console.log(`B ä¸º A è´¡çŒ®äº† ${count} æ¬¡å¹¿å‘Šè§‚çœ‹`);
   */
  async getReferralAdCount(referrerId, referralId) {
    if (!this.isReady()) {
      return 0;
    }
    
    try {
      const key = `user:referral:ad:${referrerId}:${referralId}`;
      const count = await this.client.get(key);
      return count ? parseInt(count) : 0;
    } catch (error) {
      console.error('è·å–æ¨èå¹¿å‘Šè®¡æ•°å¤±è´¥:', error.message);
      return 0;
    }
  }

  // ==================== é‚€è¯·è¿›åº¦ç¼“å­˜ ====================
  // ä½¿ç”¨ Hash å­˜å‚¨ç”¨æˆ·çš„é‚€è¯·ç»Ÿè®¡ä¿¡æ¯

  /**
   * ç¼“å­˜ç”¨æˆ·é‚€è¯·è¿›åº¦
   * 
   * ã€æ•°æ®ç»“æ„ã€‘
   * Key: user:invite:progress:{user_id}
   * Type: Hash
   * Fields: total_count, milestone_5_claimed, milestone_10_claimed, referral_ad_rewards
   * TTL: æ— ï¼ˆé•¿æœŸç¼“å­˜ï¼‰
   * 
   * ã€ä¸ºä»€ä¹ˆä¸è®¾ç½®TTLã€‘
   * - é‚€è¯·æ•°æ®å¾ˆé‡è¦ï¼Œä¸èƒ½éšæ„è¿‡æœŸ
   * - æ•°æ®å˜åŒ–ä¸é¢‘ç¹ï¼ˆåªåœ¨æ–°å¢é‚€è¯·æ—¶æ›´æ–°ï¼‰
   * - æ•°æ®é‡å°ï¼ˆæ¯ä¸ªç”¨æˆ·ä¸€ä¸ª Hashï¼‰
   * 
   * ã€é‡Œç¨‹ç¢‘å¥–åŠ±ã€‘
   * - é‚€è¯· 5 äººï¼šå¥–åŠ±Aï¼ˆmilestone_5_claimed æ ‡è®°æ˜¯å¦å·²é¢†å–ï¼‰
   * - é‚€è¯· 10 äººï¼šå¥–åŠ±Bï¼ˆmilestone_10_claimed æ ‡è®°æ˜¯å¦å·²é¢†å–ï¼‰
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @param {number} totalCount - æ€»é‚€è¯·äººæ•°
   * @param {boolean} milestone5Claimed - 5äººé‡Œç¨‹ç¢‘æ˜¯å¦å·²é¢†å–
   * @param {boolean} milestone10Claimed - 10äººé‡Œç¨‹ç¢‘æ˜¯å¦å·²é¢†å–
   * @param {number} referralAdRewards - æ¨èå¹¿å‘Šå¥–åŠ±æ€»é¢
   * @returns {Promise<boolean>} true=æˆåŠŸ, false=å¤±è´¥
   * 
   * @example
   * await redisClient.cacheInvitationProgress(
   *   'U001',
   *   8,      // é‚€è¯·äº†8äºº
   *   true,   // 5äººå¥–åŠ±å·²é¢†å–
   *   false,  // 10äººå¥–åŠ±æœªé¢†å–
   *   120     // è·å¾—120ç§¯åˆ†å¹¿å‘Šå¥–åŠ±
   * );
   */
  async cacheInvitationProgress(userId, totalCount, milestone5Claimed, milestone10Claimed, referralAdRewards) {
    if (!this.isReady()) {
      return false;
    }
    
    try {
      const key = `user:invite:progress:${userId}`;
      const data = {
        total_count: totalCount.toString(),                   // æ•°å­—è½¬å­—ç¬¦ä¸²
        milestone_5_claimed: milestone5Claimed ? '1' : '0',   // å¸ƒå°”è½¬ '1'/'0'
        milestone_10_claimed: milestone10Claimed ? '1' : '0', // å¸ƒå°”è½¬ '1'/'0'
        referral_ad_rewards: referralAdRewards.toString()     // æ•°å­—è½¬å­—ç¬¦ä¸²
      };
      
      await this.client.hmset(key, data);
      // æ³¨æ„ï¼šä¸è®¾ç½® EXPIREï¼Œé•¿æœŸç¼“å­˜
      return true;
    } catch (error) {
      console.error('ç¼“å­˜é‚€è¯·è¿›åº¦å¤±è´¥:', error.message);
      return false;
    }
  }

  /**
   * è·å–ç”¨æˆ·é‚€è¯·è¿›åº¦ç¼“å­˜
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Promise<Object|null>} é‚€è¯·è¿›åº¦å¯¹è±¡æˆ– null
   * 
   * @example
   * const progress = await redisClient.getInvitationProgress('U001');
   * if (progress && progress.totalCount >= 5 && !progress.milestone5Claimed) {
   *   // å¯ä»¥é¢†å–5äººé‡Œç¨‹ç¢‘å¥–åŠ±
   *   await claimMilestone(userId, 5);
   * }
   */
  async getInvitationProgress(userId) {
    if (!this.isReady()) {
      return null;
    }
    
    try {
      const key = `user:invite:progress:${userId}`;
      const data = await this.client.hgetall(key);
      
      if (!data || Object.keys(data).length === 0) {
        return null;
      }
      
      return {
        totalCount: parseInt(data.total_count) || 0,           // å­—ç¬¦ä¸²è½¬æ•°å­—
        milestone5Claimed: data.milestone_5_claimed === '1',   // '1' è½¬ true
        milestone10Claimed: data.milestone_10_claimed === '1', // '1' è½¬ true
        referralAdRewards: parseInt(data.referral_ad_rewards) || 0 // å­—ç¬¦ä¸²è½¬æ•°å­—
      };
    } catch (error) {
      console.error('è·å–é‚€è¯·è¿›åº¦ç¼“å­˜å¤±è´¥:', error.message);
      return null;
    }
  }

  /**
   * åˆ é™¤ç”¨æˆ·é‚€è¯·è¿›åº¦ç¼“å­˜
   * 
   * ã€ä½¿ç”¨åœºæ™¯ã€‘
   * - ç”¨æˆ·é‚€è¯·æ•°æ®å‘ç”Ÿå˜åŒ–ï¼šåˆ é™¤ç¼“å­˜ï¼Œä¸‹æ¬¡ä»æ•°æ®åº“åˆ·æ–°
   * - é‡Œç¨‹ç¢‘å¥–åŠ±é¢†å–åï¼šåˆ é™¤ç¼“å­˜ï¼Œæ›´æ–°çŠ¶æ€
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Promise<boolean>} true=åˆ é™¤æˆåŠŸ, false=å¤±è´¥
   */
  async deleteInvitationProgress(userId) {
    if (!this.isReady()) {
      return false;
    }
    
    try {
      const key = `user:invite:progress:${userId}`;
      await this.client.del(key);
      return true;
    } catch (error) {
      console.error('åˆ é™¤é‚€è¯·è¿›åº¦ç¼“å­˜å¤±è´¥:', error.message);
      return false;
    }
  }

  // ==================== æ¯æ—¥åŠ æˆç”¨æˆ·ç®¡ç† ====================
  // ä½¿ç”¨ Sorted Set ç®¡ç†æ¿€æ´»æ¯æ—¥åŠ æˆçš„ç”¨æˆ·åˆ—è¡¨

  /**
   * æ·»åŠ ç”¨æˆ·åˆ°æ¯æ—¥åŠ æˆæ¿€æ´»åˆ—è¡¨
   * 
   * ã€æ•°æ®ç»“æ„ã€‘
   * Key: daily:bonus:active
   * Type: Sorted Set (æœ‰åºé›†åˆ)
   * Score: è¿‡æœŸæ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
   * Member: user_id
   * TTL: æ— ï¼ˆæ‰‹åŠ¨æ¸…ç†è¿‡æœŸæˆå‘˜ï¼‰
   * 
   * ã€ä¸ºä»€ä¹ˆä½¿ç”¨ Sorted Setã€‘
   * - éœ€è¦æŒ‰è¿‡æœŸæ—¶é—´æ’åº
   * - éœ€è¦å¿«é€ŸæŸ¥æ‰¾æŸç”¨æˆ·æ˜¯å¦æ¿€æ´»ï¼ˆZSCORE O(log N)ï¼‰
   * - éœ€è¦æ‰¹é‡æ¸…ç†è¿‡æœŸç”¨æˆ·ï¼ˆZREMRANGEBYSCORE O(log N + M)ï¼‰
   * 
   * ã€æ•°æ®ç¤ºä¾‹ã€‘
   * ```
   * daily:bonus:active
   * 1734220800000 â†’ U001  (2025-12-15 00:00:00 è¿‡æœŸ)
   * 1734307200000 â†’ U002  (2025-12-16 00:00:00 è¿‡æœŸ)
   * 1734393600000 â†’ U003  (2025-12-17 00:00:00 è¿‡æœŸ)
   * ```
   * 
   * ã€ä¸šåŠ¡é€»è¾‘ã€‘
   * - ç”¨æˆ·ç­¾åˆ°æˆåŠŸ â†’ æ¿€æ´»7å¤©æ¯æ—¥åŠ æˆ
   * - åŠ æˆè¿‡æœŸ â†’ è‡ªåŠ¨å¤±æ•ˆ
   * - æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡è¿‡æœŸç”¨æˆ·ï¼ˆå®šæ—¶ä»»åŠ¡ï¼‰
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @param {number} expireTimestamp - è¿‡æœŸæ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
   * @returns {Promise<boolean>} true=æ·»åŠ æˆåŠŸ, false=å¤±è´¥
   * 
   * @example
   * // ç”¨æˆ·ç­¾åˆ°ï¼Œæ¿€æ´»7å¤©åŠ æˆ
   * const expireTime = Date.now() + 7 * 24 * 60 * 60 * 1000;
   * await redisClient.addDailyBonusUser('U001', expireTime);
   */
  async addDailyBonusUser(userId, expireTimestamp) {
    if (!this.isReady()) {
      return false;
    }
    
    try {
      const key = 'daily:bonus:active';
      // ZADDï¼šæ·»åŠ æˆå‘˜åˆ°æœ‰åºé›†åˆ
      // score = è¿‡æœŸæ—¶é—´æˆ³, member = ç”¨æˆ·ID
      await this.client.zadd(key, expireTimestamp, userId);
      return true;
    } catch (error) {
      console.error('æ·»åŠ æ¯æ—¥åŠ æˆç”¨æˆ·å¤±è´¥:', error.message);
      return false;
    }
  }

  /**
   * ä»æ¯æ—¥åŠ æˆåˆ—è¡¨ä¸­ç§»é™¤ç”¨æˆ·
   * 
   * ã€ä½¿ç”¨åœºæ™¯ã€‘
   * - ç”¨æˆ·æ‰‹åŠ¨å–æ¶ˆåŠ æˆ
   * - æµ‹è¯•æ—¶éœ€è¦é‡ç½®ç”¨æˆ·çŠ¶æ€
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Promise<boolean>} true=ç§»é™¤æˆåŠŸ, false=å¤±è´¥
   * 
   * @example
   * await redisClient.removeDailyBonusUser('U001');
   */
  async removeDailyBonusUser(userId) {
    if (!this.isReady()) {
      return false;
    }
    
    try {
      const key = 'daily:bonus:active';
      await this.client.zrem(key, userId); // ZREMï¼šä»æœ‰åºé›†åˆç§»é™¤æˆå‘˜
      return true;
    } catch (error) {
      console.error('ç§»é™¤æ¯æ—¥åŠ æˆç”¨æˆ·å¤±è´¥:', error.message);
      return false;
    }
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·çš„æ¯æ—¥åŠ æˆæ˜¯å¦æ¿€æ´»
   * 
   * ã€å®ç°é€»è¾‘ã€‘
   * 1. ZSCOREï¼šè·å–ç”¨æˆ·çš„åˆ†æ•°ï¼ˆè¿‡æœŸæ—¶é—´æˆ³ï¼‰
   * 2. æ¯”è¾ƒï¼šscore > now ? æ¿€æ´» : æœªæ¿€æ´»
   * 
   * ã€æ€§èƒ½ã€‘
   * - æ—¶é—´å¤æ‚åº¦ï¼šO(log N)ï¼ŒN ä¸ºé›†åˆå¤§å°
   * - é€‚åˆé«˜é¢‘è°ƒç”¨ï¼ˆæ¯æ¬¡è®¡ç®—æŒ–çŸ¿æ”¶ç›Šéƒ½è¦æ£€æŸ¥ï¼‰
   * 
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Promise<boolean>} true=æ¿€æ´»ä¸­, false=æœªæ¿€æ´»æˆ–å·²è¿‡æœŸ
   * 
   * @example
   * const isActive = await redisClient.isDailyBonusActive('U001');
   * const multiplier = isActive ? 2.0 : 1.0;
   * const reward = baseReward * multiplier;
   */
  async isDailyBonusActive(userId) {
    if (!this.isReady()) {
      return false;
    }
    
    try {
      const key = 'daily:bonus:active';
      const now = Date.now(); // å½“å‰æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
      
      // ZSCOREï¼šè·å–ç”¨æˆ·çš„åˆ†æ•°ï¼ˆè¿‡æœŸæ—¶é—´æˆ³ï¼‰
      const score = await this.client.zscore(key, userId);
      
      if (!score) {
        return false; // ç”¨æˆ·ä¸åœ¨é›†åˆä¸­ï¼Œæœªæ¿€æ´»
      }
      
      // æ¯”è¾ƒï¼šè¿‡æœŸæ—¶é—´ > å½“å‰æ—¶é—´ ? æ¿€æ´» : å·²è¿‡æœŸ
      return parseInt(score) > now;
    } catch (error) {
      console.error('æ£€æŸ¥æ¯æ—¥åŠ æˆçŠ¶æ€å¤±è´¥:', error.message);
      return false; // å‘ç”Ÿé”™è¯¯ï¼Œè¿”å›æœªæ¿€æ´»
    }
  }

  /**
   * æ¸…ç†å·²è¿‡æœŸçš„æ¯æ—¥åŠ æˆç”¨æˆ·
   * 
   * ã€åŠŸèƒ½è¯´æ˜ã€‘
   * æ‰¹é‡åˆ é™¤æœ‰åºé›†åˆä¸­å·²è¿‡æœŸçš„æˆå‘˜ï¼ˆscore <= nowï¼‰
   * åº”å®šæ—¶è°ƒç”¨ï¼ˆå¦‚æ¯å°æ—¶ä¸€æ¬¡ï¼‰ï¼Œé¿å…é›†åˆæ— é™å¢é•¿
   * 
   * ã€å‘½ä»¤è¯´æ˜ã€‘
   * ZREMRANGEBYSCORE key min max
   * - min: '-inf'ï¼ˆè´Ÿæ— ç©·ï¼‰
   * - max: nowï¼ˆå½“å‰æ—¶é—´æˆ³ï¼‰
   * - åˆ é™¤æ‰€æœ‰ score åœ¨ [-inf, now] èŒƒå›´çš„æˆå‘˜
   * 
   * ã€å®šæ—¶ä»»åŠ¡ç¤ºä¾‹ã€‘
   * ```javascript
   * const cron = require('node-cron');
   * 
   * // æ¯å°æ—¶çš„ç¬¬0åˆ†é’Ÿæ‰§è¡Œ
   * cron.schedule('0 * * * *', async () => {
   *   const removed = await redisClient.cleanupExpiredDailyBonus();
   *   console.log(`æ¸…ç†äº† ${removed} ä¸ªè¿‡æœŸåŠ æˆç”¨æˆ·`);
   * });
   * ```
   * 
   * @returns {Promise<number>} æ¸…ç†çš„ç”¨æˆ·æ•°é‡
   * 
   * @example
   * const removed = await redisClient.cleanupExpiredDailyBonus();
   * console.log(`æ¸…ç†äº† ${removed} ä¸ªè¿‡æœŸç”¨æˆ·`);
   */
  async cleanupExpiredDailyBonus() {
    if (!this.isReady()) {
      return 0;
    }
    
    try {
      const key = 'daily:bonus:active';
      const now = Date.now();
      
      // ZREMRANGEBYSCOREï¼šåˆ é™¤åˆ†æ•°åœ¨æŒ‡å®šèŒƒå›´å†…çš„æˆå‘˜
      // '-inf' åˆ° nowï¼šæ‰€æœ‰å·²è¿‡æœŸçš„æˆå‘˜
      const removed = await this.client.zremrangebyscore(key, '-inf', now);
      
      return removed; // è¿”å›åˆ é™¤çš„æˆå‘˜æ•°é‡
    } catch (error) {
      console.error('æ¸…ç†è¿‡æœŸåŠ æˆå¤±è´¥:', error.message);
      return 0;
    }
  }

  // ==================== é€šç”¨ç¼“å­˜æ–¹æ³• ====================
  // æä¾›åŸºç¡€çš„ Redis æ“ä½œå°è£…ï¼Œé€‚ç”¨äºç®€å•åœºæ™¯

  /**
   * è®¾ç½®ç¼“å­˜
   * 
   * ã€åŠŸèƒ½è¯´æ˜ã€‘
   * é€šç”¨çš„é”®å€¼å¯¹ç¼“å­˜æ–¹æ³•ï¼Œæ”¯æŒå¯é€‰çš„è¿‡æœŸæ—¶é—´ã€‚
   * é€‚ç”¨äºç®€å•çš„å­—ç¬¦ä¸²ç¼“å­˜åœºæ™¯ã€‚
   * 
   * ã€å‘½ä»¤é€‰æ‹©ã€‘
   * - æœ‰ TTL: SETEX key seconds value (åŸå­æ“ä½œï¼Œæ¨è)
   * - æ—  TTL: SET key value
   * 
   * @param {string} key - ç¼“å­˜é”®
   * @param {string} value - ç¼“å­˜å€¼ï¼ˆå¿…é¡»æ˜¯å­—ç¬¦ä¸²ï¼Œå¤æ‚å¯¹è±¡éœ€å…ˆ JSON.stringifyï¼‰
   * @param {number|null} ttl - è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œnull è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
   * @returns {Promise<boolean>} true=è®¾ç½®æˆåŠŸ, false=å¤±è´¥
   * 
   * @example
   * // ç¼“å­˜ç”¨æˆ·tokenï¼Œ1å°æ—¶è¿‡æœŸ
   * await redisClient.set('token:U001', 'abc123xyz', 3600);
   * 
   * // ç¼“å­˜é…ç½®ï¼Œæ°¸ä¸è¿‡æœŸ
   * await redisClient.set('config:version', '1.0.0', null);
   * 
   * // ç¼“å­˜å¯¹è±¡ï¼ˆéœ€è¦åºåˆ—åŒ–ï¼‰
   * await redisClient.set('user:U001', JSON.stringify({name: 'Alice'}), 600);
   */
  async set(key, value, ttl = null) {
    if (!this.isReady()) {
      return false;
    }
    
    try {
      if (ttl) {
        // SETEXï¼šè®¾ç½®é”®å€¼å¯¹å¹¶æŒ‡å®šè¿‡æœŸæ—¶é—´ï¼ˆåŸå­æ“ä½œï¼‰
        await this.client.setex(key, ttl, value);
      } else {
        // SETï¼šè®¾ç½®é”®å€¼å¯¹ï¼Œæ°¸ä¸è¿‡æœŸ
        await this.client.set(key, value);
      }
      return true;
    } catch (error) {
      console.error(`è®¾ç½®ç¼“å­˜å¤±è´¥ [${key}]:`, error.message);
      return false;
    }
  }

  /**
   * è·å–ç¼“å­˜
   * 
   * @param {string} key - ç¼“å­˜é”®
   * @returns {Promise<string|null>} ç¼“å­˜å€¼æˆ– nullï¼ˆé”®ä¸å­˜åœ¨/å·²è¿‡æœŸ/Redis ä¸å¯ç”¨ï¼‰
   * 
   * @example
   * const token = await redisClient.get('token:U001');
   * if (token) {
   *   console.log('Tokenæœ‰æ•ˆ:', token);
   * } else {
   *   console.log('Tokenå·²è¿‡æœŸæˆ–ä¸å­˜åœ¨');
   * }
   * 
   * // è·å–å¯¹è±¡ï¼ˆéœ€è¦ååºåˆ—åŒ–ï¼‰
   * const userJson = await redisClient.get('user:U001');
   * const user = userJson ? JSON.parse(userJson) : null;
   */
  async get(key) {
    if (!this.isReady()) {
      return null;
    }
    
    try {
      return await this.client.get(key); // GETï¼šè·å–å­—ç¬¦ä¸²å€¼ï¼Œä¸å­˜åœ¨è¿”å› null
    } catch (error) {
      console.error(`è·å–ç¼“å­˜å¤±è´¥ [${key}]:`, error.message);
      return null;
    }
  }

  /**
   * åˆ é™¤ç¼“å­˜
   * 
   * @param {string} key - ç¼“å­˜é”®
   * @returns {Promise<number>} åˆ é™¤çš„é”®æ•°é‡ï¼ˆ1=åˆ é™¤æˆåŠŸ, 0=é”®ä¸å­˜åœ¨ï¼‰
   * 
   * @example
   * const deleted = await redisClient.del('token:U001');
   * if (deleted) {
   *   console.log('Tokenå·²åˆ é™¤');
   * }
   */
  async del(key) {
    if (!this.isReady()) {
      return 0;
    }
    
    try {
      return await this.client.del(key); // DELï¼šåˆ é™¤é”®ï¼Œè¿”å›åˆ é™¤æ•°é‡
    } catch (error) {
      console.error(`åˆ é™¤ç¼“å­˜å¤±è´¥ [${key}]:`, error.message);
      return 0;
    }
  }

  /**
   * æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
   * 
   * @param {string} key - ç¼“å­˜é”®
   * @returns {Promise<number>} 1=å­˜åœ¨, 0=ä¸å­˜åœ¨
   * 
   * @example
   * const exists = await redisClient.exists('token:U001');
   * if (exists) {
   *   console.log('Tokenå­˜åœ¨');
   * }
   */
  async exists(key) {
    if (!this.isReady()) {
      return 0;
    }
    
    try {
      return await this.client.exists(key); // EXISTSï¼šæ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
    } catch (error) {
      console.error(`æ£€æŸ¥é”®å­˜åœ¨å¤±è´¥ [${key}]:`, error.message);
      return 0;
    }
  }

  /**
   * è®¾ç½®è¿‡æœŸæ—¶é—´
   * 
   * ã€åŠŸèƒ½è¯´æ˜ã€‘
   * ä¸ºå·²å­˜åœ¨çš„é”®è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰ã€‚
   * å¦‚æœé”®ä¸å­˜åœ¨æˆ–å·²æœ‰è¿‡æœŸæ—¶é—´ï¼Œä¼šè¦†ç›–ã€‚
   * 
   * @param {string} key - ç¼“å­˜é”®
   * @param {number} seconds - è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
   * @returns {Promise<number>} 1=è®¾ç½®æˆåŠŸ, 0=é”®ä¸å­˜åœ¨
   * 
   * @example
   * // å…ˆè®¾ç½®å€¼
   * await redisClient.set('session:U001', 'active');
   * // åè®¾ç½®è¿‡æœŸæ—¶é—´
   * await redisClient.expire('session:U001', 3600); // 1å°æ—¶åè¿‡æœŸ
   * 
   * // å»¶é•¿è¿‡æœŸæ—¶é—´
   * await redisClient.expire('session:U001', 7200); // æ”¹ä¸º2å°æ—¶åè¿‡æœŸ
   */
  async expire(key, seconds) {
    if (!this.isReady()) {
      return 0;
    }
    
    try {
      return await this.client.expire(key, seconds); // EXPIREï¼šè®¾ç½®è¿‡æœŸæ—¶é—´
    } catch (error) {
      console.error(`è®¾ç½®è¿‡æœŸæ—¶é—´å¤±è´¥ [${key}]:`, error.message);
      return 0;
    }
  }
}

// ==================== å•ä¾‹å¯¼å‡º ====================

/**
 * åˆ›å»ºå¹¶å¯¼å‡º RedisClient å•ä¾‹
 * 
 * ã€å•ä¾‹æ¨¡å¼ã€‘
 * - å…¨å±€åªæœ‰ä¸€ä¸ª Redis è¿æ¥å®ä¾‹
 * - æ‰€æœ‰æ¨¡å—å…±äº«åŒä¸€ä¸ªè¿æ¥æ± 
 * - é¿å…é‡å¤è¿æ¥æµªè´¹èµ„æº
 * 
 * ã€ä½¿ç”¨æ–¹å¼ã€‘
 * ```javascript
 * // åœ¨ä»»ä½•æ¨¡å—ä¸­å¯¼å…¥
 * const redisClient = require('./config/redis');
 * 
 * // ç›´æ¥ä½¿ç”¨ï¼Œæ— éœ€ new
 * await redisClient.cacheUserLevel(...);
 * ```
 */
const redisClient = new RedisClient();

module.exports = redisClient;
